input {
  kafka {
    bootstrap_servers => "kafka:9092"
    topics => ["scraper-data"]
    codec => "json"
    group_id => "logstash-group"
    auto_offset_reset => "earliest"
    consumer_threads => 1
  }
}

filter {
  # Ajout d'un timestamp si non présent
  if ![timestamp] {
    mutate {
      add_field => { "timestamp" => "%{@timestamp}" }
    }
  }

  # Conversion des coordonnées en geo_point pour Elasticsearch
  if [coordinates] {
    mutate {
      rename => { "[coordinates][lat]" => "[location][lat]" }
      rename => { "[coordinates][lang]" => "[location][lon]" }
    }

    # Création d'un champ geo_point pour Elasticsearch
    mutate {
      add_field => { "[location][geo_point]" => "%{[location][lat]},%{[location][lon]}" }
    }
    
    # Ajout d'une zone géographique pour clustering
    ruby {
      code => "
        lat = event.get('[location][lat]')
        lon = event.get('[location][lon]')
        if lat && lon
          # Arrondir les coordonnées pour créer des zones
          lat_zone = (lat * 10).floor / 10.0
          lon_zone = (lon * 10).floor / 10.0
          event.set('geo_zone', lat_zone.to_s + ',' + lon_zone.to_s)
          
          # Déterminer si le restaurant est dans une zone touristique (exemple)
          # Ces coordonnées sont fictives et devraient être ajustées selon les vraies zones touristiques
          tourist_zones = [
            { lat: 30.4, lon: -9.6, name: 'Zone Balnéaire' },
            { lat: 31.6, lon: -8.0, name: 'Zone Médina' },
            { lat: 33.6, lon: -7.6, name: 'Zone Corniche' }
          ]
          
          tourist_zones.each do |zone|
            if (lat - zone[:lat]).abs < 0.1 && (lon - zone[:lon]).abs < 0.1
              event.set('tourist_zone', zone[:name])
              event.set('is_tourist_area', true)
              break
            end
          end
          
          event.set('is_tourist_area', false) unless event.get('is_tourist_area')
        end
      "
    }
  }

  # Traitement du numéro de téléphone
  if [phone_number] {
    mutate {
      gsub => [
        "phone_number", "[^0-9]", ""
      ]
    }

    if [phone_number] =~ /^0[567]\d{8}$/ {
      mutate {
        add_field => { "formatted_phone" => "%{phone_number}" }
      }
      mutate {
        gsub => [
          "formatted_phone", "(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})", "0\1 \2 \3 \4 \5"
        ]
      }
      
      # Détection de l'opérateur téléphonique
      ruby {
        code => "
          phone = event.get('phone_number')
          if phone && phone.is_a?(String)
            prefix = phone[0,3]
            operator = case prefix
              when '061', '060', '062' then 'Maroc Telecom'
              when '066', '067' then 'Orange'
              when '070', '071', '072', '073', '074' then 'Inwi'
              else 'Inconnu'
            end
            event.set('phone_operator', operator)
          end
        "
      }
    }
    
    # Vérifier si le numéro de téléphone est présent
    mutate {
      add_field => { "has_phone" => "true" }
    }
  } else {
    mutate {
      add_field => { "has_phone" => "false" }
    }
  }

  # Traitement des réseaux sociaux
  if [social_networks] {
    ruby {
      code => "
        social_networks = event.get('social_networks')
        if social_networks.is_a?(Array) && !social_networks.empty?
          social_types = {}
          platform_counts = {
            'facebook' => 0,
            'instagram' => 0,
            'twitter' => 0,
            'linkedin' => 0,
            'youtube' => 0
          }

          social_networks.each do |url|
            if url.include?('facebook.com')
              social_types['facebook'] = url
              platform_counts['facebook'] += 1
            elsif url.include?('instagram.com')
              social_types['instagram'] = url
              platform_counts['instagram'] += 1
            elsif url.include?('twitter.com') || url.include?('x.com')
              social_types['twitter'] = url
              platform_counts['twitter'] += 1
            elsif url.include?('linkedin.com')
              social_types['linkedin'] = url
              platform_counts['linkedin'] += 1
            elsif url.include?('youtube.com')
              social_types['youtube'] = url
              platform_counts['youtube'] += 1
            end
          end

          # Stockage des informations sur les réseaux sociaux
          event.set('social_media', social_types)
          event.set('has_social_media', true)
          event.set('social_media_count', social_types.size)
          
          # Stockage des compteurs par plateforme
          platform_counts.each do |platform, count|
            event.set('has_' + platform, count > 0)
          end
          
          # Classification de la présence sur les réseaux sociaux
          case social_types.size
            when 0
              event.set('social_presence', 'aucune')
            when 1
              event.set('social_presence', 'minimale')
            when 2
              event.set('social_presence', 'modérée')
            when 3
              event.set('social_presence', 'bonne')
            else
              event.set('social_presence', 'excellente')
          end
        else
          event.set('has_social_media', false)
          event.set('social_media_count', 0)
          event.set('social_presence', 'aucune')
          ['facebook', 'instagram', 'twitter', 'linkedin', 'youtube'].each do |platform|
            event.set('has_' + platform, false)
          end
        end
      "
    }
  }

  # Traitement de la note (rating)
  if [rating] {
    mutate {
      convert => { "rating" => "float" }
    }

    if [rating] >= 4.5 {
      mutate { add_field => { "rating_category" => "excellent" } }
    } else if [rating] >= 4.0 {
      mutate { add_field => { "rating_category" => "très bon" } }
    } else if [rating] >= 3.5 {
      mutate { add_field => { "rating_category" => "bon" } }
    } else if [rating] >= 3.0 {
      mutate { add_field => { "rating_category" => "moyen" } }
    } else {
      mutate { add_field => { "rating_category" => "à améliorer" } }
    }
    
    # Conversion en score sur 10 pour faciliter les comparaisons
    ruby {
      code => "
        rating = event.get('rating')
        if rating && rating.is_a?(Numeric)
          # Convertir en score sur 10
          score_10 = (rating * 2).round(1)
          event.set('score_10', score_10)
        end
      "
    }
  }

  # Traitement du nombre d'avis
  if [review_count] {
    mutate {
      convert => { "review_count" => "integer" }
    }

    if [review_count] >= 500 {
      mutate { add_field => { "popularity" => "très populaire" } }
    } else if [review_count] >= 100 {
      mutate { add_field => { "popularity" => "populaire" } }
    } else if [review_count] >= 50 {
      mutate { add_field => { "popularity" => "modéré" } }
    } else {
      mutate { add_field => { "popularity" => "peu connu" } }
    }
    
    # Calcul d'un score d'influence combinant note et nombre d'avis
    ruby {
      code => "
        rating = event.get('rating')
        review_count = event.get('review_count')
        
        if rating && review_count && rating.is_a?(Numeric) && review_count.is_a?(Numeric)
          # Formule: (note * log10(nombre_avis + 1)) / 5
          # Donne un score entre 0 et ~2 pour les restaurants très populaires et bien notés
          influence_score = (rating * Math.log10(review_count + 1)) / 5
          event.set('influence_score', influence_score.round(2))
          
          # Classification de l'influence
          case 
          when influence_score >= 1.5
            event.set('influence_category', 'référence locale')
          when influence_score >= 1.0
            event.set('influence_category', 'très influent')
          when influence_score >= 0.7
            event.set('influence_category', 'influent')
          when influence_score >= 0.4
            event.set('influence_category', 'modéré')
          else
            event.set('influence_category', 'faible')
          end
        end
      "
    }
  }

  # Traitement de la fourchette de prix
  if [price_range] {
    ruby {
      code => "
        price = event.get('price_range')
        if price && price.is_a?(String)
          if price.include?('MAD')
            price_level = price.scan(/MAD/).size
            event.set('price_level', price_level)

            case price_level
            when 1
              event.set('price_category', 'économique')
              event.set('price_range_numeric', 75) # Moyenne estimée: 50-100 MAD
            when 2
              event.set('price_category', 'intermédiaire')
              event.set('price_range_numeric', 150) # Moyenne estimée: 100-200 MAD
            when 3
              event.set('price_category', 'élevé')
              event.set('price_range_numeric', 300) # Moyenne estimée: 200-400 MAD
            when 4..Float::INFINITY
              event.set('price_category', 'luxe')
              event.set('price_range_numeric', 500) # Moyenne estimée: 400+ MAD
            end
            
            # Extraction des valeurs numériques si disponibles
            if price =~ /MAD\s*(\d+)[–-](\d+)/
              min_price = $1.to_i
              max_price = $2.to_i
              avg_price = (min_price + max_price) / 2
              
              event.set('min_price', min_price)
              event.set('max_price', max_price)
              event.set('avg_price', avg_price)
              
              # Remplacer l'estimation par la moyenne réelle si disponible
              event.set('price_range_numeric', avg_price)
            end
          end
        end
      "
    }
  }

  # Enrichissement avec des informations sur le site web
  if [website] {
    ruby {
      code => "
        website = event.get('website')
        if website && website.is_a?(String)
          domain = website.gsub(/^https?:\/\//, '').gsub(/^www\./, '').split('/')[0]
          event.set('website_domain', domain)

          is_https = website.start_with?('https://')
          event.set('website_secure', is_https)

          # Détection du type de site web
          if domain.include?('wix.com') || domain.include?('wordpress.com') ||
             domain.include?('blogspot.com') || domain.include?('squarespace.com')
            event.set('website_type', 'plateforme')
          else
            event.set('website_type', 'domaine personnalisé')
          end
          
          # Détection de la présence de réservation en ligne
          has_booking = website.include?('reservation') || 
                        website.include?('booking') || 
                        website.include?('reserve') ||
                        domain.include?('thefork') ||
                        domain.include?('lafourchette') ||
                        domain.include?('opentable')
          
          event.set('has_online_booking', has_booking)
          
          # Détection du TLD pour analyse de marché
          tld = domain.split('.').last
          event.set('website_tld', tld)
          
          # Classification de la maturité numérique
          digital_score = 0
          digital_score += 1 if is_https
          digital_score += 1 if event.get('website_type') == 'domaine personnalisé'
          digital_score += 1 if has_booking
          digital_score += [event.get('social_media_count').to_i, 2].min
          
          event.set('digital_maturity_score', digital_score)
          
          case digital_score
          when 0..1
            event.set('digital_maturity', 'débutant')
          when 2..3
            event.set('digital_maturity', 'intermédiaire')
          when 4..5
            event.set('digital_maturity', 'avancé')
          end
        end
      "
    }
    
    # Vérifier si le site web est présent
    mutate {
      add_field => { "has_website" => "true" }
    }
  } else {
    mutate {
      add_field => { "has_website" => "false" }
      add_field => { "digital_maturity" => "absent" }
      add_field => { "digital_maturity_score" => 0 }
    }
  }

  # Traitement de la cuisine
  if [cuisine] {
    ruby {
      code => "
        cuisine = event.get('cuisine')
        if cuisine && cuisine.is_a?(String)
          # Normalisation et catégorisation des types de cuisine
          cuisine_lower = cuisine.downcase
          
          cuisine_category = if cuisine_lower.include?('restaurant')
            if cuisine_lower.include?('traditionnel') || cuisine_lower.include?('marocain')
              'cuisine marocaine'
            elsif cuisine_lower.include?('italien') || cuisine_lower.include?('pizza') || cuisine_lower.include?('pasta')
              'cuisine italienne'
            elsif cuisine_lower.include?('français') || cuisine_lower.include?('bistro')
              'cuisine française'
            elsif cuisine_lower.include?('asiatique') || cuisine_lower.include?('chinois') || cuisine_lower.include?('japonais') || cuisine_lower.include?('sushi')
              'cuisine asiatique'
            elsif cuisine_lower.include?('fast') || cuisine_lower.include?('burger') || cuisine_lower.include?('sandwich')
              'fast-food'
            elsif cuisine_lower.include?('poisson') || cuisine_lower.include?('fruit de mer') || cuisine_lower.include?('seafood')
              'fruits de mer'
            elsif cuisine_lower.include?('végé')
              'végétarien/vegan'
            else
              'restaurant général'
            end
          elsif cuisine_lower.include?('café') || cuisine_lower.include?('coffee')
            'café'
          elsif cuisine_lower.include?('pâtisserie') || cuisine_lower.include?('boulangerie')
            'pâtisserie/boulangerie'
          elsif cuisine_lower.include?('glacier') || cuisine_lower.include?('ice cream')
            'glacier'
          elsif cuisine_lower.include?('bar') || cuisine_lower.include?('pub')
            'bar/pub'
          else
            'autre'
          end
          
          event.set('cuisine_category', cuisine_category)
          
          # Détection si c'est un fast-food
          is_fast_food = cuisine_lower.include?('fast') || 
                         cuisine_lower.include?('burger') || 
                         cuisine_lower.include?('sandwich') ||
                         cuisine_lower.include?('pizza') ||
                         cuisine_lower.include?('kebab')
          
          event.set('is_fast_food', is_fast_food)
          
          # Détection si c'est un restaurant végétarien/vegan
          is_vegetarian = cuisine_lower.include?('végé') || 
                          cuisine_lower.include?('vegan') ||
                          cuisine_lower.include?('plant')
          
          event.set('is_vegetarian', is_vegetarian)
        end
      "
    }
  }

  # Ajout d'un champ de recherche global
  mutate {
    add_field => {
      "search_text" => "%{company_name} %{[address][city]} %{cuisine}"
    }
  }

  # Découpage des adresses
  grok {
    match => { "address" => "%{DATA:street}, %{DATA:district}, %{DATA:city}, %{DATA:province}, %{DATA:region}, %{DATA:postal_code}, %{DATA:country}" }
  }
  
  ruby {
    code => "
      ['city', 'province', 'region', 'country'].each do |field|
        val = event.get(field)
        if val
          val = val.gsub(/[\u0600-\u06FF\u2D30-\u2D7F]/, '')  # supprime arabe et amazigh
          event.set(field, val.strip)
        end
      end
    "
  }
  
  # Enrichissement des données géographiques
  ruby {
    code => "
      city = event.get('city')
      if city && city.is_a?(String)
        # Classification des villes par taille
        city_size = case city.downcase
          when 'casablanca', 'rabat', 'marrakech', 'fes', 'tanger'
            'grande ville'
          when 'agadir', 'meknes', 'oujda', 'kenitra', 'tetouan'
            'ville moyenne'
          else
            'petite ville'
        end
        
        event.set('city_size', city_size)
        
        # Détection des zones touristiques par ville
        tourist_city = ['marrakech', 'agadir', 'essaouira', 'chefchaouen', 'fes', 'tanger'].include?(city.downcase)
        event.set('is_tourist_city', tourist_city)
      end
    "
  }
  
  # Calcul d'un score global d'attractivité
  ruby {
    code => "
      # Collecte des facteurs
      rating = event.get('rating')
      review_count = event.get('review_count')
      price_level = event.get('price_level')
      digital_maturity_score = event.get('digital_maturity_score')
      has_website = event.get('has_website') == 'true'
      social_media_count = event.get('social_media_count')
      is_tourist_city = event.get('is_tourist_city')
      
      if rating && rating.is_a?(Numeric)
        # Calcul du score (sur 100)
        score_components = []
        
        # Note (max 40 points)
        score_components << (rating / 5.0 * 40) if rating
        
        # Nombre d'avis (max 20 points)
        if review_count && review_count.is_a?(Numeric)
          review_score = [review_count / 500.0 * 20, 20].min
          score_components << review_score
        end
        
        # Prix (max 10 points - les restaurants intermédiaires sont favorisés)
        if price_level && price_level.is_a?(Numeric)
          price_score = case price_level
            when 2 then 10  # Prix intermédiaire = idéal
            when 1, 3 then 8  # Économique ou élevé = bon
            else 5  # Luxe = moins accessible
          end
          score_components << price_score
        end
        
        # Présence numérique (max 20 points)
        digital_score = 0
        digital_score += has_website ? 8 : 0
        digital_score += digital_maturity_score.to_i * 2 if digital_maturity_score
        digital_score += [social_media_count.to_i * 3, 12].min if social_media_count
        score_components << [digital_score, 20].min
        
        # Localisation (max 10 points)
        location_score = is_tourist_city ? 10 : 5
        score_components << location_score
        
        # Calcul du score final
        if !score_components.empty?
          attractiveness_score = score_components.sum.round(1)
          event.set('attractiveness_score', attractiveness_score)
          
          # Classification
          case attractiveness_score
          when 80..100
            event.set('attractiveness_category', 'exceptionnelle')
          when 70..79.9
            event.set('attractiveness_category', 'excellente')
          when 60..69.9
            event.set('attractiveness_category', 'très bonne')
          when 50..59.9
            event.set('attractiveness_category', 'bonne')
          when 40..49.9
            event.set('attractiveness_category', 'moyenne')
          else
            event.set('attractiveness_category', 'à améliorer')
          end
        end
      end
    "
  }
  
  # Ajout de la date d'indexation pour les analyses temporelles
  mutate {
    add_field => {
      "indexed_date" => "%{+YYYY-MM-dd}"
    }
  }
}

output {
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    index => "business-%{+YYYY.MM.dd}"
    document_id => "%{company_RC}"
    action => "index"
  }

  stdout {
    codec => rubydebug
  }
}
